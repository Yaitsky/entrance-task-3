# Задание 3 - Школа разработки интерфейсов Яндекс

Мобилизация.Гифки – сервис для поиска гифок в перерывах между занятиями.

Сервис написан с использованием [bem-components](https://ru.bem.info/platform/libs/bem-components/5.0.0/).

Работа избранного в оффлайне реализована с помощью технологии [Service Worker](https://developer.mozilla.org/ru/docs/Web/API/Service_Worker_API/Using_Service_Workers).

Для поиска изображений используется [API сервиса Giphy](https://github.com/Giphy/GiphyAPI).

В браузерах, не поддерживающих сервис-воркеры, приложение так же должно корректно работать, 
за исключением возможности работы в оффлайне.

## Структура проекта

  * `gifs.html` – точка входа
  * `assets` – статические файлы проекта
  * `vendor` –  статические файлы внешних библиотек
  * `service-worker.js` – скрипт сервис-воркера

Открывать `gifs.html` нужно с помощью локального веб-сервера – не как файл. 
Это можно сделать с помощью встроенного в WebStorm/Idea веб-сервера, с помощью простого сервера
из состава PHP или Python. Можно воспользоваться и любым другим способом.


#Решение

##Исправление багов

###Первая проблема (местоположение файла service-worker.js)

Service-worker находится в папке /assets, в связи с чем, его область видимости
ограничивается папкой /assets. 
Для того, чтобы область видимости service-worker'a
охватывала все приложение, файл был перемещен в корневую папку проекта
Также была исправлена ссылка на service-worker.js в файле block.js

###Вторая проблема (отсутствие слежения за файлом gifs.html)

После устранения первой проблемы service-worker смог видеть все статические файлы, однако
оффлайн режим так и не работает. Это связано с тем, что при проверке функции `needStoreForOffline()`
service-worker выбирает исполнение функции `fetchWithFallbackToCache()`, что приводит к ошибке подключения.
А так как файл `gifs.html` не был сохранен, корректной работы приложения не происходит.
Для решения данной проблемы в функцию `needStoreForOffline()` была добавлена проверка на `gifs.html`

###Третья проблема (некорректная обработка события fetch)

``` js
response = caches.match(cacheKey)
    .then(cacheResponse => cacheResponse || fetchAndPutToCache(cacheKey, event.request));
```
Данный блок кода приводит к тому, что файл будет браться из кеша, пока кэш не будет очищен.
В данном примере данный блок кода был исправлен таким образом, чтобы сначала был выполнен запрос, 
а в случае ошибки было выполнено обращение к кэшу.
``` js
response = fetchAndPutToCache(cacheKey, event.request);
```

###Четвертая проблема (отсутствие обновления статических файлов)

Для корректного обновления статических файлов было обновление `CACHE_VERSION` (любое другое значение),
таким образом стала корректно работать проверка в функции `deleteObsoleteCaches`;

###Возможность переключения в оффлайн-режим после первого запроса

Для реализации данного требования было добавлено кэширование всех файлов на стадии установки
service-worker'a. Таким образом стало возможно переключение в оффлайн-режим сразу же после первого
запроса.


##Ответы на вопросы

Вопрос №1: зачем нужен этот вызов?

Ответ: вызов `skipWaiting()` выполняется при обновлении service-worker'a. Данный вызов позволяет
сразу же начинать работу нового service-worker'a (без режима ожидания, пока все предыдущие 
service-worker'ы прекратят свою работу)

Вопрос №2: зачем нужен этот вызов?

Ответ: вызов `clients.claim()` сразу же активирует service-worker без необходимости перезагрузки 
страницы

Вопрос №3: для всех ли случаев подойдёт такое построение ключа?

Ответ: Нет. Данное построение ключа не подойдет для GET-запросов с использованием параметров
поиска. Отсутствует обращение к `URL.searchParams`.

Вопрос №4: зачем нужна эта цепочка вызовов?

Ответ: Данная цепочка вызовов удаляет кэш старой версии.
Метод filter делает проверку на текущую версию кэша.
Метод map вызывает функцию для каждого элемента массива.
Конструкция Promise.all возвращается промис, который разрешается только тогда, 
когда разрешаются все промисы, находящиеся в ней (caches.delete возвращает промис). 

Вопрос №5: для чего нужно клонирование?

Ответ: Запрос - это поток, который может быть обработан только один раз. 
Если мы хотим использовать объект запроса/ответа несколько раз, его нужно клонировать.